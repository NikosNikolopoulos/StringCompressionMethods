## Static Huffman Algorithm
Huffman encoding is achieved by constructing the `Huffman Tree` which has properties favourable for encoding. As far as the static Huffman algorithm is concerned, the coding process starts with an initial scan of the text (text to be encoded) to create an "alphabet" of frequencies for each character, i.e., a list of characters is constructed which is accompanied by their respective frequencies of occurrence in the given text (input text). Then, we insert the elements of the alphabet with the frequencies into a min heap and perform two deletions of the least element from the heap (delete min) and obtain as output the elements with the two smallest frequency fields, which could be achieved in many ways but for the implementation of the static Huffman algorithm the use of a heap was preferred. When executing the command delete min from the heap (delete min) the `Huffman Tree` is constructed, specifically for the pair of elements deleted from the min heap a node - element with a frequency field equal to the sum of the frequencies of the deleted pair of elements is created which has as right child the node - element with the lowest frequency of the two elements deleted from the heap and as left child the other node - element, the character field (char) remains empty in the new node. Next, we insert the new parent node into the min heap and follow the same steps by performing two successive min heap deletions, thus the `Huffman Tree` will start to form. In this way, we manage to select each time the nodes - elements with the smallest frequency fields and assign to them as parent a node - element with frequency field the sum of their frequencies. By iteratively executing the above procedure until we reach the root of the tree, i.e. until we arrive at a heap with two nodes - elements and perform delete min, we obtain the completed `Huffman Tree`. Finally, to assign a codeword to each character of the alphabet it is enough for each internal node of `Huffman Tree` to attach the value "0" to the edges leading to the left child and the value "1" to the other edges (the attachment of values to the edges can be done arbitrarily). The decoding process is made obvious and easy by using the Huffman tree constructed for the input text.

## Self-Adaptive Huffman Algorithm 
Regarding the dynamic self-adaptive Huffman algorithm, the following flowcharts make it easy to create classes and methods for text encoding and decoding. That is, the flowcharts adequately describe the dynamic Huffman algorithm as well as partition the encoding problem into smaller tractable subproblems. In addition, the dynamic Huffman algorithm has the property of generating a Huffman Tree on each character-symbol it encounters while scanning the text.

![Encoding & decoding procedure](https://github.com/NikosNikolopoulos/StringCompressionMethods/tree/main/Report/EncodingDecodingProcedure.png)

![Update procedure](https://github.com/NikosNikolopoulos/StringCompressionMethods/tree/main/Report/UpdateProcedure.png)
